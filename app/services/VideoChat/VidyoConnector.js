/*
  VidyoConnector functions should call only on client side.

  Connection flow: 
    1. Define which browser is.                                    | (browserCompatability)
    2. Generate link for downloading VidyoSDK.                     | (loadVidyoClientLibrary)
    3. If a browser compatibile only with plugin, download plugin. | (getPluginUrl)
    4. Create object which connect front-end with Vidyo's server.  | (createVidyoConnector)
    5. Connect to the videochat.                                   | (connectVidyoConnector)
*/

import bowser from 'bowser';

import VidyoListeners from './VidyoListeners';

const VidyoConnector = {
  /* 
      loadVidyoClientLibrary function return: 
        1. isNeedPlugin - true if browser require plugin 
        2. isWebrtc - true if browser compatibile with webrtc without plugin
        3. onDidSDKLoad - name of global functions, which will be called after 
        SDK downloaded. This argument should be string
  */
  generateVidyoSDKUrl: ({ onDidSDKLoad }) => {
    // If webrtc, then set webrtcLogLevel
    let webrtcLogLevel = '';
    if (webrtc) {
      // Set the WebRTC log level to either: 'info' (default), 'error', or 'none'
      webrtcLogLevel = '&webrtcLogLevel=info';
    }

    let plugin = false; // true if browser require plugin 
    let webrtc = false; // true if browser compatibile with webrtc without plugin

    // TODO: determine AppleWebKit in Mac
    switch (bowser.name) {
      case 'Chrome':
        webrtc = true;
        break;
      case 'Firefox':
        webrtc = true;
        break;
      case 'Safari':
        plugin = true;
        break;
      case 'msie':
        plugin = true;
        break;
      default:
    }

    // We need to ensure we're loading the VidyoClient library and listening for the callback.
    return `https://static.vidyo.io/4.1.15.7/javascript/VidyoClient/VidyoClient.js?onload=${onDidSDKLoad}&webrtc=${webrtc}&plugin=${plugin}${webrtcLogLevel}`;
  },

  // Plugin's link
  getPluginUrl(status) {
    // Url to the plugin
    return status.downloadPathPlugIn;
  },

  // VC - global Vidyo object, which generate
  // VidyoConnection establishing helper
  createVidyoConnector: async (VC) => {
    try {
      const vidyoConnector = await VC.CreateVidyoConnector({
        viewId: null,
        viewStyle: 'VIDYO_CONNECTORVIEWSTYLE_Default',
        remoteParticipants: 2,
        logFileFilter: 'warning info@VidyoClient info@VidyoConnector',
        logFileName: '',
        userData: 0
      });

      return vidyoConnector;
    } catch (error) {
      throw error;
    }
  },

  /*
    vidyConnector is an object which generated by createVidyoConnector function
      1. vidyoToken
      2. resourceId
      3. handlers: 
        1) onSuccess
        2) onFailure
        3) onDisconnect
  */
  connectVidyoConnector: async (vidyoConnector, {
    displayName,
    resourceId,
    vidyoToken,
    onSuccess,
    onFailure,
    onDisconnected
  }) => {
    try {
      const status = await vidyoConnector.Connect({
        host: 'prod.vidyo.io',
        token: vidyoToken,
        displayName,
        resourceId,
        onSuccess,
        onFailure,
        onDisconnected
      });

      return status;
    } catch (error) {
      throw error;
    }
  },
  registerDeviceListeners: async (vidyoConnector, {
    cameraListeners,
    microphoneListeners,
    speakerListeners,
    remoteCameraListeners,
    chatListener
  }) => {
    try {
      const cameraRes = VidyoListeners.registerCameraListener(vidyoConnector, cameraListeners);
      const microphoneRes = VidyoListeners.registerMicrophoneListener(
        vidyoConnector,
        microphoneListeners
      );
      const speakerRes = VidyoListeners.registerSpeakerListener(vidyoConnector, speakerListeners);
      const remoteCameraRes = VidyoListeners.registerRemoteCameraListener(
        vidyoConnector,
        remoteCameraListeners
      );

      const chatRes = VidyoListeners.registerMessageEventListener(
        vidyoConnector,
        chatListener
      );

      return { cameraRes, microphoneRes, speakerRes, remoteCameraRes, chatRes };
    } catch (error) {
      throw error;
    }
  },
  assignViewToLocalCamera: async ({
    vidyoConnector,
    localCamera,
    viewId,
    displayCropped,
    allowZoom
  }) => {
    try {
      await vidyoConnector.AssignViewToLocalCamera({
        viewId,
        localCamera,
        displayCropped,
        allowZoom
      });
    } catch (error) {
      throw error;
    }
  },
  assignViewToRemoteCamera: async ({
    vidyoConnector,
    remoteCamera,
    viewId,
    displayCropped,
    allowZoom
  }) => {
    try {
      await vidyoConnector.AssignViewToRemoteCamera({
        viewId,
        remoteCamera,
        displayCropped,
        allowZoom
      });
    } catch (error) {
      throw error;
    }
  },

  hideViewToLocalCamera: async ({ vidyoConnector, viewId }) => {
    try {
      await vidyoConnector.HideView({ viewId });
    } catch (error) {
      throw error;
    }
  },

  hideViewToRemoteCamera: async ({ vidyoConnector, viewId }) => {
    try {
      await vidyoConnector.HideView({ viewId });
    } catch (error) {
      throw error;
    }
  }
};

export default VidyoConnector;
