/*
  VidyoConnector functions should call only on client side.

  Connection flow: 
    1. Define which browser is.                                    | (browserCompatability)
    2. Generate link for downloading VidyoSDK.                     | (loadVidyoClientLibrary)
    3. If a browser compatibile only with plugin, download plugin. | (getPluginUrl)
    4. Create object which connect front-end with Vidyo's server.  | (createVidyoConnector)
    5. Connect to the videochat.                                   | (connectVidyoConnector)
*/

import bowser from 'bowser';

import VidyoListeners from './VidyoListeners';

const VidyoConnector = {
  /* 
      loadVidyoClientLibrary function return: 
        1. isNeedPlugin - true if browser require plugin 
        2. isWebrtc - true if browser compatibile with webrtc without plugin
        3. onDidSDKLoad - name of global functions, which will be called after 
         SDK downloaded. This argument should be string
  */
  loadVidyoSDK: ({ webrtc, plugin, onDidSDKLoad }) => {
    // If webrtc, then set webrtcLogLevel
    let webrtcLogLevel = '';
    if (webrtc) {
      // Set the WebRTC log level to either: 'info' (default), 'error', or 'none'
      webrtcLogLevel = '&webrtcLogLevel=info';
    }

    // We need to ensure we're loading the VidyoClient library and listening for the callback.
    return `https://static.vidyo.io/4.1.15.7/javascript/VidyoClient/VidyoClient.js?onload=${onDidSDKLoad}&webrtc=${webrtc}&plugin=${plugin}${webrtcLogLevel}`;
  },

  /*
    browserCompatability function return object with shape:
      1. isNeedPlugin - true if browser require plugin 
      2. isWebrtc - true if browser compatibile with webrtc without plugin
  */
  browserCompatability: () => {
    // TODO determine AppleWebKit in Mac
    switch (bowser.name) {
      case 'Chrome':
        return { isNeedPlugin: false, isWebrtc: true };
      case 'Firefox':
        return { isNeedPlugin: false, isWebrtc: true };
      case 'Safari':
        return { isNeedPlugin: true, isWebrtc: false };
      case 'msie':
        return { isNeedPlugin: true, isWebrtc: false };
      default:
        return { isNeedPlugin: false, isWebrtc: false };
    }
  },

  // Plugin's link
  getPluginUrl(status) {
    // Url to the plugin
    return status.downloadPathPlugIn;
  },

  // VC - global Vidyo object, which generate
  // VidyoConnection establishing helper
  createVidyoConnector: async (VC) => {
    try {
      const vidyoConnector = await VC.CreateVidyoConnector({
        viewId: null,
        viewStyle: 'VIDYO_CONNECTORVIEWSTYLE_Default',
        remoteParticipants: 16,
        logFileFilter: 'warning info@VidyoClient info@VidyoConnector',
        logFileName: '',
        userData: 0
      });

      return vidyoConnector;
    } catch (error) {
      return error;
    }
  },

  /*
    vidyConnector is an object which generated by createVidyoConnector function
    ListenerComponent is React Component which must contain: 
      1. vidyoToken
      2. resourceId
      3. handlers: 
        1) onSuccess
        2) onFailure
        3) onDisconnect
  */
  connectVidyoConnector: async (vidyoConnector, ListenerComponent) => {
    try {
      const status = await vidyoConnector.Connect({
        host: 'prod.vidyo.io',
        token: ListenerComponent.vidyoToken,
        displayName: 'John',
        resourceId: ListenerComponent.resourceId,
        // Define handlers for connection events.
        onSuccess: ListenerComponent.handleConnectionSuccess,
        onFailure: ListenerComponent.handleConnectionFailure,
        onDisconnected: ListenerComponent.handleConnectionDisconnect
      });

      return status;
    } catch (error) {
      console.log('Error with connection: ', error);
      return false;
    }
  },

  registerDeviceListeners: async (vidyoConnector, ListenerComponent) => {
    try {
      const cameraRes = VidyoListeners.registerCameraListener(vidyoConnector, ListenerComponent);
      const microphoneRes = VidyoListeners.registerMicrophoneListener(
        vidyoConnector,
        ListenerComponent
      );
      const speakerRes = VidyoListeners.registerSpeakerListener(vidyoConnector, ListenerComponent);
      const remoteCameraRes = VidyoListeners.registerRemoteCameraListener(
        vidyoConnector,
        ListenerComponent
      );

      const chatRes = VidyoListeners.registerMessageEventListener(
        vidyoConnector,
        ListenerComponent
      );

      return { cameraRes, microphoneRes, speakerRes, remoteCameraRes, chatRes };
    } catch (error) {
      return error;
    }
  },

  assignViewToLocalCamera: async ({
    vidyoConnector,
    localCamera,
    viewId,
    displayCropped,
    allowZoom
  }) => {
    try {
      await vidyoConnector.AssignViewToLocalCamera({
        viewId,
        localCamera,
        displayCropped,
        allowZoom
      });
    } catch (error) {
      return error;
    }
  },
  assignViewToRemoteCamera: async ({
    vidyoConnector,
    remoteCamera,
    viewId,
    displayCropped,
    allowZoom
  }) => {
    try {
      await vidyoConnector.AssignViewToRemoteCamera({
        viewId,
        remoteCamera,
        displayCropped,
        allowZoom
      });
    } catch (error) {
      return error;
    }
  },

  hideViewToLocalCamera: async ({ vidyoConnector, viewId }) => {
    try {
      await vidyoConnector.HideView({ viewId });
    } catch (error) {
      return error;
    }
  },

  hideViewToRemoteCamera: async ({ vidyoConnector, viewId }) => {
    try {
      await vidyoConnector.HideView({
        viewId
      });
    } catch (error) {
      return error;
    }
  }
};

export default VidyoConnector;
